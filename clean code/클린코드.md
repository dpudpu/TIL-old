

[Clean Code](http://www.yes24.co.kr/Product/goods/11681152) (로버트 C. 마틴 저/박재호, 이해영 역) 에서 필요한 부분만 빼서 요약한 내용입니다.



### 깨끗한 코드란?

c++ 창시자 비야네 스트롭스트룹 

```
나는우아하고효율적인코드를좋아힌다 논리 가 간단 해야 버그가 숨어들지 못한다 의존성을 최대힌 줄여야 유지보수가 쉬워진디. 오류는 명 백한전략에의거해철저히처리한다. 성능을최 적으로 유지해야 사람들이 원칙 없는 최적화로 코드플 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다
```

  비야네는 철저한 오류 처리도 언급한다. 세세한 사항까지 꼼꼼하게 신경 쓰라는 말이다. 프로그래머들이 대충 넘어가는 부분 중 하나가 오류 처리다. 메모리 누수, 경쟁 상태, 일관선 없는 명명법이 또 다른 예다. 한 마디로 요악하면, 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다.

 마지막으로 비야네는 깨끗한 코드란 한 가지를 잘 한다고 당언한다. 수많은 소프트웨어 설계 원칙이 이 간단한 교훈 하나로 귀결된다는 사실은 우연이 아니다. 수많은 저술가들이 이 생각을 나름대로 표현하려 애썼다. 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다. 깨끗한 코드는 한 가지에 '집중'한다. 각 함수와 클래스와 모듈을 주변 상황에 현혹되거나 오렴되지 않은 채 한길만 걷는다.



그래디 부치

```
깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도플 숨기지 않는다. 오히려 병쾌한 추상화와 단순한 제어문으로 가득하다.
```



데이브 토마스

```
깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다 단위 테스트 케이스와 인수 테스 트 케이스가존재한다， 깨끗한 코드에는 의미 있 는 이름이 붙는다， 특정 목적을 달성하는 방법은 (여러 가지가 아니라) 하나만 제공한다. 의존성 은 최소이며 각 의존성을 멍확히 정의한다‘ API 는 명확하며 최소로 줄였다 언어애 따라 필요한 모든 정보를 코드만으로 병확히 표현할 수 없기 에 코드는 문학적으로 표현해야 마땅하다.
```



마이클 페더스 - 코드를 주의 깊게 짜는 방법

```
깨끗한 코드의 특정은 많지만 그 중에서도 모두를 아우르는 특정이 하나 있다 깨끗한 코드는 언제나 누군가 주의 깊게 썼다는 느낌 을준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로. 고칠 궁리를 하다보면 언제나 제자리로 돌아온다 그리고는 누군가 남겨준 코드 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다
```



 메서드가 여러 기능을 수행한다면 메서드 추출ExtractMethod 리팩터링 기볍을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.





## 2장. 의미 있는 이름

# 의도를 분명히 밝혀라

좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다. 

의도가 드러나는 이름을 사용하면 코드 이해와 변경이 쉬워진다. 다음 코드는 무엇을 할까?

```java
public List<int[]> getThem(){
    List<int[]> list1 = new ArrayList<int[]>();
    for(int[] x : theList)
        if(x[0] == 4)
            list.add(x);
    return list1;
}
```

 코드가 하는 일을 짐작하기 어렵다. 문제는 코드의 단순성이 아니라 함축성이다. 다시 말해, 코드 맥락이 코드 자체에 명시적으로 드러나지 않는다. 위 코드는 암암리에 독자가 정보를 안다고 가정한다.



지뢰찾기 게임을 만든다고 가정하자. 그러면 theList가 게임판이라는 사실을 안다. theList를 gameBoard로 바꿔보자. 

 게임판에서 각 칸은 단순 배열로 표현한다. 배열에서 0번째 값은 칸 상태를 뜻한다. 값 4는 깃발이 꽂힌 상태를 가리킨다. 각 개념에 이름만 붙여도 코드가 상당히 나아진다. 

```java
public List<int[]> getFlaggedCells() {
	List<int[]> flaggedCells = new ArrayList<int[]>(); 
    for (int[] cell : gameBoard)
        if (cell[STATUS_VALUE] == FLAGGED) 
            flaggedCells.add(cell);
    return flaggedCells;
}
```

 위에서 보듯, 코드의 단순성은 변하지 않았다. 연산자 수와 상수 수는 앞의 예와 똑같으며, 들여쓰기 단계도 동일하다. 그런데도 코드는 더욱 명확해졌다.

 한 걸음 더 나아가, int배열을 사용하는 대신, 칸을 간단한 클래스로 만들어도 되겠다. isFlagged라는 좀 더 명시적인 함수를 사용해 FLAGGED라는 상수를 감춰도 좋겠다. 

```java
public List<int[]> getFlaggedCells() {
	List<int[]> flaggedCells = new ArrayList<Cell>(); 
    for (Cell cell : gameBoard)
        if (cell.isFlagged()) 
            flaggedCells.add(cell);
    return flaggedCells;
}
```

단순히 이름만 고쳤는데도 함수가 하는 일을 이해하기 쉬워졌다. 바로 이것이 좋은 이름이 주는 위력이다.



#### 의미 있게 구분하라

#### 발음하기 쉬운 이름을 사용하라

#### 검색하기 쉬운 이름을 사용하라

#### 인코딩을 피하라

#### 자신의 기억력을 자랑하지마라

#### 클래스 이름

클래스 이름과 객체이름은 명사나 명사구가 적합하다. 



#### 메서드 이름

메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등이 좋은 예다. 접근자, 변경자, 조건자는 javabean 표준에 따라 값 앞에 get, set, is를 붙인다.

생성자를 중복정의(overload)할 때는 정적. 팩토리 메서드를 사용한다. 메서드는 인수를 설명하는 이름을 사용한다. 예를 들어, 다음 두 예제를 살펴보자.

``` java
Complex flucrumPoint = Complex.FromRealNumber(23.0);

Complext flcrumPoint = new Complext(23.0);
```

위 코드가 아래 코드보다 좋다.

생성자 사용을 제한 하려면 해당 생서자를 private로 선언한다.



#### 기발한 이름은 피하라

#### 한 개념에 한 단어를 사용하라

추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. 예를 들어, 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다. 어느 클래스에서 어느 이름을 썼는지 기억하기 어렵다.



#### 해법 영역에서 가져온 이름을 사용하라

코드를 읽을 사람도 프로그래머라는 사실을 명심한다. 그러므로 전산 용어, 알고리즘 이름, 패턴 이름 등을 사용해도 괜ㅊ낳다. 모든 이름을 문제 영역(domain)에서 가져오는 정책은 현명하지 못한다. 같은 개념을 다른 이름으로 이해하던 동료들이 매번 고객에게 의미를 물어야하기 때문이라.

#### 문제 영역에서 가져온 이름을 사용하라

적절한 '프로그래머 용어'가 없다면 문제 영역에서 이름을 가져온다. 

우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄 알아야한다. 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.



#### 의미 있는 맥락을 추가하라

#### 불필요한 맥락을 없애라

‘고급 휘발유 충전소 GasStation Deluxe’라는 애플리케이션을 찬다고 가정하자. 모든 클래스 이름을 GSD로 시작하겠다는 생각은 전혀 바람직하지 못하다. IDE에서 G를 입력하고 자동 완성 키를 누르면 IDE는 모든 클래스를 열거한다. 현명하지 못하다. IDE는 개발자를 지원하는 도구다. IDE를 방해할 이유는 없다.

