#### 출처 : 자바 ORM표준 JPA 프로그래밍 저자: 김영한



## 1. 엔티티

JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션을 필수로 붙여야한다. 

@Entity가 붙은 클래스는 JPA가 관리하는 것으로, 엔티티라 부른다.

Entity는 반드시 식별자(@Id)를 가지고 있어야한다. (타입은 Long으로 해주는게 좋다.) - 크기

영속성: 기본적으로 컴퓨터 공학에서 영속성이라고 하면 **비휘발성**이라고 보면 될 것 같다.

  



## 2. 엔티티매니저 팩토리와 엔티티 매니저

엔티티 매니저는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든 일을 처리한다. 이름 그대로 엔티티를 관리하는 관리자다.



엔티티 매니저 팩토리는 이름 그대로 엔티티 매니저를 만드는 공장인데, 공장을 만드는 비용은 상당히 크다. 따라서 한개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다. 반면에 공장에서 엔티티 매니저를 생성하는 비용은 거의 들지 않는다. 그리고 **엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.**



## 3. 영속성 컨텍스트

**영속성 컨텍스트란?**  '엔티티를 영구 저장하는 환경'

엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다.(persist() 메소드 사용)

####  

#### 3.1 엔티티의 생명주기 

- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 아직 저장하지 않은 순수한 객체 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태 (영속성 컨텍스트에 의해 관리)
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태.   

​      

#### 3.2 영속성 컨텍스트의 특징

- 영속 상태는 식별자 값이 반드시 있어야 한다.(@Id)
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush라 한다.
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩



#### 3.3 엔티티 조회

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 **1차 캐시**라 한다.

영속 상태의 엔티티는 모두 이곳에 저장된다. 쉽게 이야기하면 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 식별자고 값은 엔티티 인스턴스다.

##### 1차 캐시에서 조회

em.find()를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다. 만약 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다. 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속성 상태의 엔티티를 반환한다.

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member2");
a==b -> true
```

영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.



- 엔티티매니저가 리턴해주는건 Member가 아닌 Member를 상속받은 Proxy객체를 리턴해준다.

- 아이디를 자동생성 해놨으면 트랜잭션이 끝났을때가 아니라 중간에 Insert된다.

- 영속성이 부여되었을때(save, getone) 스냅샷(복사본)이 만들어진다.

- 원본(객체)을 수정하면 스냅샷과 비교해서 바뀐게 있으면 자동으로 업데이트 된다.

- jpa에는 update가 없다. 
- hibernate는 sql을 최대한 줄이려고 늦게 실행하려고 한다.
- test클래스에서 @Tansactional을 붙이면 원복되서 DB에 반영되지 않는다.



